>If a variable or parameter is declared to have type T&& for some deduced type T, that variable or parameter is a universal reference.
>
>如果一个变量或者参数被声明为 T&&，其中 T 是被推导的类型，那这个变量或者参数就是一个 universal reference。

C++11 中有万能引用（Universal Reference）的概念：使用 T&& 类型的形参既能绑定右值，又能绑定左值。

但是注意了：只有发生类型推导的时候，T&& 才表示万能引用；否则，表示右值引用。比如下面的代码，

```c++
template<typename T>
void func(T&& param) {
    cout << param << endl;
}


int main() {
    int num = 2019;
    func(num);
    func(2019);
    return 0;
}
```

如何区分 T&& 是万能引用还是右值引用呢？重点在于**是否发生类型推导**，下面是一些例子，

```c++
// 是万能引用
Widget&& var1 = someWidget;
auto&& var2 = var1;

// 是万能引用
std::vector<int> v;
auto&& val = v[0]; 

// 是右值引用
Widget(Widget&& rhs);

// 是万能引用
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs);
};

// 是右值引用
template<typename T>
void f(std::vector<T>&& param); 

// 我们同时有类型推导和一个带 && 的参数，但是参数确不具有 T&& 的形式，而是 std::vector<t>&&。其结果就是，参数就只是一个普通的 rvalue reference，而不是 universal reference。
// Universal references 只以 T&& 的形式出现！即便是仅仅加一个 const 限定符都会使得 && 不再被解释为 universal reference，例如，
// 是右值引用
template<typename T>
void f(const T&& param);
```

有的时候你可以在函数模板的声明中看到 T&&，但却没有发生类型推导。来看下 std::vector 的 push_back 函数:

```
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x);       // fully specified parameter type ⇒ no type deduction;
    ...                          // && ≡ rvalue reference
};
```

这里, T 是模板参数, 并且 push_back 接受一个 T&&, 但是这个参数却不是 universal reference! 这怎么可能?

如果我们看看 push_back 在类外部是如何声明的，这个问题的答案就很清楚了，

```c++
template <class T>
void vector<T>::push_back(T&& x);
```

push_back 不能离开 std::vector<T> 这个类而独立存在。但如果我们有了一个叫做 std::vector<T> 的类，我们就已经知道了 T 是什么东西，那就没必要推导 T。

举个例子可能会更好。如果我这么写:

```c++
Widget makeWidget();             // factory function for Widget
std::vector<Widget> vw;
...
Widget w;
vw.push_back(makeWidget());      // create Widget from factory, add it to vw
```

代码中对 push_back 的使用会让编译器实例化类 std::vector<Widget> 相应的函数。这个 push_back 的声明看起来像这样:

```c++
void std::vector<Widget>::push_back(Widget&& x);
```

看到了没? 一旦我们知道了类是 std::vector<Widget>，push_back 的参数类型就完全确定了: 就是 Widget&&。这里完全不需要进行任何的类型推导。

对比下 std::vector 的 emplace_back，它看起来是这样的:

```c++
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); // deduced parameter types ⇒ type deduction;
    ...                                // && ≡ universal references
};
```

emplace_back 看起来需要多个参数(Args 和 args 的声明当中都有...)，但重点是每一个参数的类型都需要进行推导。函数的模板参数 Args 和类的模板参数 T 无关，所以即使我知道这个类具体是什么，比如说，std::vector<Widget>，但我们还是不知道 emplace_back 的参数类型是什么。

我们看下在类 std::vector<Widget> 外面声明的 emplace_back会 更清楚的表明这一点:

```c++
template<class... Args>
void std::vector<Widget>::emplace_back(Args&&... args);
```

## 参考

- <https://zhuanlan.zhihu.com/p/99524127>
