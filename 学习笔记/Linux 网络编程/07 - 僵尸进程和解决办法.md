# 孤儿进程和僵尸进程

**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，
并由 init 进程对它们完成状态收集工作。

**僵尸进程**：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

任何一个子进程(init 除外)在退出后并非马上就消失，而是留下一个称作僵尸进程的数据结构，等待父进程处理。这是每个子进程都必需经历的阶段。另外子进程退出的时候会向其父进程发送一个 SIGCHLD 信号。

# 解决方案

1. 通过 signal(SIGCHLD, SIG_IGN) 通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句 signal(SIGCHLD,SIG_IGN);表示父进程忽略 SIGCHLD 信号，该信号是子进程退出的时候向父进程发送的。
2. 父进程调用 wait/waitpid 函数等待子进程结束，如果尚无子进程退出 wait 会导致父进程阻塞。waitpid 可以通过传递 WNOHANG 使父进程不阻塞立即返回。
3. 如果父进程很忙可以用 signal 注册信号处理函数，在信号处理函数调用 wait/waitpid 等待子进程退出。
4. 通过两次调用fork。父进程首先调用 fork 创建一个子进程然后 waitpid 等待子进程退出，子进程再 fork 一个个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于子孙进程，其父进程已经退出，所以子孙进程成为一个孤儿进程，孤儿进程由 init 进程接管，孙进程结束后，init 会等待回收。

第一种方法忽略 SIGCHLD 信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常 fork 很多子进程，子进程终结之后需要服务器进程去 wait 清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给 init 进程去处理，省去了大量僵尸进程占用系统资源。













# 参考

- [linux下的僵尸进程处理SIGCHLD信号](https://www.cnblogs.com/wuchanming/p/4020463.html)
